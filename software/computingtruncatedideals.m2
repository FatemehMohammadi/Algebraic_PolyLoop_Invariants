computebasis = method()
computebasis(ZZ,ZZ,List,List) :=(n,d,mp,c)-> (
i = 0;
while i < length mp do (
    F_i = join((mp)_i, {x_(n+1)*G});
    i = i+1
    );
    maps = {F_0};
i =1;
while i<length mapping() do (
maps = join(maps, {F_i});
i = i+1;
);
    ---Using a vector basis of the (d-1)th truncated ideal to find a lower bound for the dimension of the dth truncated ideal. 
    r =0;
     if d>1 then (
    computebasis(n,d-1,mp,c);
    I = ideal(A);
    J = ideal(0_R);
    i=0;
    while i< numgens I do (
   	v = (degree I_i)_0;
    	m = d -v; 
     	S = 1;
    	j=1 ;
    	while j< n+1 do (
    	    S = S+x_j;
    	    j= j+1;
    	    );
    	if m > -1 then(
    	    C = first entries monomials S^m;
    	    j =0;
    	    while j< length C do (
        	J = ideal(J, I_i*C_j);
		j=j+1;	
		);
    	    );
    	i = i+1;
    	);
    --- The dimension of the dth truncated ideal is greater than or equal to the following number r.
    	r = rank (coefficients gens J)_1 ;
    );
    M = binomial(n+d,d);
    bm = M;
    rm = M;
    ad = 1;
    e= sub(e,R);
        t = 1 ;
while t<n+2 do (
    x_t =sub(x_t,R);
    t =t+1;
    );
    t = 1 ;
while t<M+2 do (
    y_t =sub(y_t,R);
    t =t+1;
    );
G = sub(G, R);
    if length mp !=1 then (
    	rm= floor(log(length mp, M+1-r))+1;
    	ad = 0;
    );
--- Delete the next column
    S = 1;
    i =1 ;
---Generating all monomials with n variables up to degree d.     
    while i< n+1 do (
    	S = S+x_i;
    	i = i+1;
    	);
    C = first entries monomials S^d;
    g =0;
    i=1;
     while i<bm+1 do (
    	g = g+y_i*C_(i-1);
    	i = i+1;
    	);
---Generating a general polynomial of degree d with n variables
M = computeCanM(mp, c,{g},rm-r*ad);
M = matrix M;
e =sub(e,R);
       t = 1 ;
while t<n+2 do (
    x_t =sub(x_t,R);
    t =t+1;
    );
    t = 1 ;
while t<bm+2 do (
    y_t =sub(y_t,R);
    t =t+1;
    );
G = sub(G, R);
---Compute candidates
A = ker M;
B = matrix{{ }};
A = generators A;
N = matrix{C};
---Generating candidates
P =N*A;
l = numgens source P;
---Finding a vector basis for a truncated ideal.
if l > 0 then (
 ---Checking that all candidates are polynomial invariants simultaneously
 X= {x_(n+1)*P_(0,0)};
 N=0;
 j=1;
while j< l do(
    X = join(X, {x_(n+1)*P_(0,j)});
    j=j+1;
    );
Xt = Compose(X,maps,n+1);
while InRadical(Xt, X) == false do(
X = join(X, Xt);
Xt= Compose(Xt, maps,n+1);
N= N+1;
print N;
);
     D = {x_1=>c_0};
	    t =  2;
	    while t<n+2 do(
		D =join(D,{x_t=>c_(t-1)});
		t=t+1; 
		);
    S=  sub(ideal X,D);    
if S == ideal(0_R) then(
   A = P;  
    );
---If one of the candidates is not polynomial invariants, then find polynomial invariants from the candidates.
if S!=ideal(0_R) then(
A = matrix{{}};
j =0;
while j< l do(
X = {x_(n+1)*P_(0,j)};
N=0;
Xt = Compose(X,maps,n+1);
while InRadical(Xt, X) == false do(
X = join(X, Xt);
Xt= Compose(Xt, maps,n+1);
N= N+1;
print N;
);
     D = {x_1=>c_0};
	    t =  2;
	    while t<n+2 do(
		D =join(D,{x_t=>c_(t-1)});
		t=t+1; 
		);
     D = {x_1=>c_0};
	    t =  2;
	    while t<n+2 do(
		D =join(D,{x_t=>c_(t-1)});
		t=t+1; 
		);
    S=  sub(ideal X,D);
    if S == ideal(0_R) then(
    A =A|matrix{{P_(0,j)}};   
    ); 
if S != ideal(0_R) then (
	B=B|matrix{{P_(0,j)}};
);
    j=j+1; 
);
);
);
---Finding the rest of basis vectors from the vector space generated by candidates which are not polynomial invariants.
if numgens source B > 1 then( 
    h = 0;
    i =0;
    while i< numgens source B do(
	C = B_i;
	h = h+z_(i+1)*C_0;
	i = i+1;
	);
    print h;
    X = {x_(n+1)*h};
N=0;
Xt = Compose(X,maps,n+1);
while InRadical(Xt, X) == false do(
X = join(X, Xt);
Xt= Compose(Xt, maps,n+1);
N= N+1;
print N;
);
     D = {x_1=>c_0};
	    t =  2;
	    while t<n+2 do(
		D =join(D,{x_t=>c_(t-1)});
		t=t+1; 
		);
     D = {x_1=>c_0};
	    t =  2;
	    while t<n+2 do(
		D =join(D,{x_t=>c_(t-1)});
		t=t+1; 
		);
     T=  sub(X,D);
     T = trim T;
     print T;
     l = numgens T;
     S = {};
     m = numgens source B;
     i =0;
     while i< l do(
    	 Um_i =S;
    	 j =1;
    	 k = 2;
    	 a_1 =1;
    	 while k<m+2 do (
	     a_k =0;
	     k=k+1;
	     );
    	 while j <  m+1 do(
	     t = 1;
	     D = {z_1=>a_1};
	     while t< numgens source B do (
		 t = t+1;
		 D = join(D,{z_t=>a_t});
		 );
	     ba=sub(T_i,D);       
	     Um_i = join(Um_i, {ba});   
	     a_j = a_(j+1);
    	     a_(j+1)= a_(j+1)+1;
	     j = j+1;
	     );
    	 i = i+1;
    	 );  
     M = matrix{Um_0, Um_1};
     i=0;
     while i< l-2 do(
    	 M = M||matrix{ Um_(i+2)};
    	 i = i+1;
    	 );
     A1=ker M;
     print M;
     A1 = generators A1;
     v = transpose B;
     P = transpose(v)*A1;
     A=A|P;
    );
)


end --
Generating polynomial invariants up to given degree.
